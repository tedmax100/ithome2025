---
title: "Day 15：Helm Chart 開發深入（上）"
tags: 2025鐵人賽
date: 2025-07-20
---


####  Day 15：Helm Chart 開發深入（上）
##### 重點
Chart.yaml 與 values.yaml 設計
模板函數與管道
條件判斷與流程控制

#####  Lab
開發完整的應用 Chart
使用條件判斷處理不同環境
實作常用 Helper 模板


學習目標
深入了解 Chart.yaml 與 values.yaml 的設計原則
掌握 Helm 模板函數與管道的使用
學會條件判斷與流程控制
開發完整的應用 Chart

# 什麼是 Helm Chart？
## 基本概念
Helm Chart 是一個打包格式，用來描述一組相關的 Kubernetes 資源。可以把它想像成：

APT/YUM 套件 - 但是針對 Kubernetes 應用程式
Docker Compose - 但是更強大且專為 Kubernetes 設計
應用程式安裝包 - 包含所有部署所需的配置和資源

## Chart 的結構
```
my-app-chart/
├── Chart.yaml          # Chart 的基本資訊
├── values.yaml         # 預設配置值
├── templates/          # Kubernetes 資源模板
│   ├── deployment.yaml
│   ├── service.yaml
│   └── ingress.yaml
└── charts/            # 依賴的其他 Charts
```

## 為什麼需要 Helm Chart？
### 解決的核心問題
問題 1：複雜的 YAML 管理
沒有 Helm 的情況：
```
# 需要管理多個 YAML 檔案
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml  
kubectl apply -f ingress.yaml
kubectl apply -f configmap.yaml
kubectl apply -f secret.yaml
```

使用 Helm 後：
```
# 一個命令部署整個應用
helm install my-app ./my-app-chart
```

問題 2：環境差異管理
沒有 Helm 的情況：
```yaml
# deployment-dev.yaml
spec:
  replicas: 1
  containers:
  - image: myapp:dev
    resources:
      limits:
        memory: "256Mi"

# deployment-prod.yaml  
spec:
  replicas: 5
  containers:
  - image: myapp:v1.2.3
    resources:
      limits:
        memory: "1Gi"
```

使用 Helm 後：
```yaml
# 一個模板，多個環境配置
# templates/deployment.yaml
spec:
  replicas: {{ .Values.replicaCount }}
  containers:
  - image: {{ .Values.image.repository }}:{{ .Values.image.tag }}
    resources:
      limits:
        memory: {{ .Values.resources.limits.memory }}
```

```yaml
# values-dev.yaml
replicaCount: 1
image:
  tag: dev
resources:
  limits:
    memory: "256Mi"

# values-prod.yaml
replicaCount: 5
image:
  tag: v1.2.3
resources:
  limits:
    memory: "1Gi"
```

## Helm Chart 的核心作用
### 模板化與參數化
```yaml
# 模板化前 - 硬編碼
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-backend-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-backend-app
  template:
    spec:
      containers:
      - name: app
        image: myorg/my-app:v1.0.0
        ports:
        - containerPort: 8080
```

```yaml
# 模板化後 - 可配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "my-app.fullname" . }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      {{- include "my-app.selectorLabels" . | nindent 6 }}
  template:
    spec:
      containers:
      - name: {{ .Chart.Name }}
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
        ports:
        - containerPort: {{ .Values.service.targetPort }}
```

## 版本管理與回滾
```bash
# 部署新版本
helm upgrade my-app ./my-app-chart --set image.tag=v2.0.0

# 查看部署歷史
helm history my-app

# 回滾到上一版本
helm rollback my-app 1
```

## 依賴管理
```yaml
# Chart.yaml
dependencies:
  - name: postgresql
    version: "~12.1.0"
    repository: "https://charts.bitnami.com/bitnami"
  - name: redis
    version: "~17.3.0"  
    repository: "https://charts.bitnami.com/bitnami"
```

```bash
# 自動安裝依賴
helm dependency update
helm install my-app ./my-app-chart
# 會同時安裝 PostgreSQL 和 Redis
```

# 實際應用場景
微服務部署
假設你有一個電商系統，包含：

用戶服務
商品服務
訂單服務
支付服務
資料庫
快取


沒有 Helm：
```bash
# 需要逐一部署每個服務
kubectl apply -f user-service/
kubectl apply -f product-service/
kubectl apply -f order-service/
kubectl apply -f payment-service/
kubectl apply -f database/
kubectl apply -f cache/
```

使用 Helm：
```
# 一個 Chart 包含所有服務
helm install ecommerce ./ecommerce-chart
```

多環境部署
```bash
# 開發環境
helm install ecommerce-dev ./ecommerce-chart \
  --values values-dev.yaml

# 測試環境  
helm install ecommerce-test ./ecommerce-chart \
  --values values-test.yaml

# 生產環境
helm install ecommerce-prod ./ecommerce-chart \
  --values values-prod.yaml
```


應用程式分發
```bash
# 打包 Chart
helm package ./my-app-chart

# 上傳到 Chart Repository
helm repo add myrepo https://charts.mycompany.com
helm push my-app-chart-1.0.0.tgz myrepo

# 其他人可以直接安裝
helm repo update
helm install my-app myrepo/my-app-chart
```


## 比較 Helm Chart vs 其他方案
vs 純 Kubernetes YAML
特性	純 YAML	Helm Chart
學習曲線	簡單	中等
模板化	❌	✅
參數化	❌	✅
版本管理	❌	✅
依賴管理	❌	✅
回滾能力	❌	✅

# 實際範例：部署一個 Web 應用
傳統方式
```bash
# 需要準備多個檔案
cat > deployment.yaml << EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
      - name: webapp
        image: nginx:1.20
        ports:
        - containerPort: 80
EOF

cat > service.yaml << EOF
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
spec:
  selector:
    app: webapp
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
EOF

# 部署
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
```

使用 Helm Chart
```bash
# 建立 Chart
helm create webapp

# 自訂配置
cat > webapp/values.yaml << EOF
replicaCount: 3
image:
  repository: nginx
  tag: "1.20"
service:
  type: ClusterIP
  port: 80
EOF

# 部署
helm install my-webapp ./webapp

# 升級
helm upgrade my-webapp ./webapp --set replicaCount=5

# 回滾
helm rollback my-webapp 1
```

# Helm Chart 的價值總結
## 對開發者的價值
簡化部署：一個命令部署複雜應用
環境一致性：相同的 Chart 可以部署到不同環境
版本控制：應用程式版本和配置版本都可以追蹤

## 對運維團隊的價值
標準化：統一的部署和管理方式
自動化：與 CI/CD 流程整合
可觀測性：統一的監控和日誌收集

## 對組織的價值
知識共享：Chart 可以在團隊間共享
最佳實踐：封裝部署的最佳實踐
降低複雜度：隱藏 Kubernetes 的複雜性