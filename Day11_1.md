---
title: "Day 11: 本地開發環境的資料庫管理實踐 - 用 DevSpace + Flyway 打造完美開發體驗"
tags: 2025鐵人賽
date: 2025-07-20
---
🎯 學習目標
今天我們要解決一個實際問題：如何在 Kubernetes 環境中，像使用 Docker Compose 一樣簡單地管理資料庫和 Migration？

想像一下，你習慣了 docker-compose up 一鍵啟動所有服務，現在要轉到 Kubernetes，是不是覺得很複雜？別擔心，今天我們用 DevSpace + Flyway 來解決這個問題！

📚 今天你會學到
🐳 從 Docker Compose 思維轉換到 Kubernetes
🚀 使用 DevSpace 簡化本地開發流程
🗄️ 整合 Flyway Migration 到開發工作流
🔄 建立完整的資料庫管理自動化
🛠️ 解決常見開發環境問題

🤔 問題：從 Docker Compose 到 Kubernetes 的痛點
Docker Compose 的美好時光
還記得用 Docker Compose 開發是多麼簡單嗎？

Docker compose 開發流程
```yaml=
# docker-compose.yml - 傳統本地開發
version: '3.8'
services:
  # 資料庫服務
  postgres:
    image: postgres:14
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - ./init-scripts:/docker-entrypoint-initdb.d  # 🎯 自動執行初始化
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
  
  # Flyway Migration
  flyway:
    image: flyway/flyway:8
    command: -url=jdbc:postgresql://postgres:5432/myapp -user=postgres -password=password migrate
    volumes:
      - ./migrations:/flyway/sql  # 🎯 Migration 腳本
    depends_on:
      - postgres  # 🎯 自動等待資料庫
  
  # 應用程式
  app:
    build: .
    environment:
      DATABASE_URL: postgresql://postgres:password@postgres:5432/myapp
    ports:
      - "3000:3000"
    depends_on:
      - flyway  # 🎯 確保 Migration 完成
    volumes:
      - .:/app  # 🎯 熱重載開發

volumes:
  postgres_data:
```

開發流程超簡單：
```bash
# 一鍵啟動所有服務（包含資料庫初始化和 Migration）
docker-compose up -d

# 查看所有服務日誌
docker-compose logs -f

# 進入資料庫檢查
docker-compose exec postgres psql -U postgres -d myapp

# 重新執行 Migration
docker-compose restart flyway
```


# Day 9B: 本地開發環境的數據庫管理實踐

## 🎯 學習目標

在上一篇學會 StatefulSet 基礎概念後，今天我們要解決實際開發中的問題：如何在 Kubernetes 環境中建立類似 Docker Compose 的本地開發體驗，包括數據庫初始化、Schema Migration、以及與應用程式的整合測試。

### 📚 學習重點
- 使用 DevSpace 簡化本地開發流程
- 整合 SQL 初始化腳本到 StatefulSet
- 實現 Flyway Migration 自動化
- 建立完整的本地開發工作流
- 解決常見的開發環境問題

---

## 🐳 從 Docker Compose 到 Kubernetes

### 傳統 Docker Compose 開發流程

```yaml
# docker-compose.yml - 傳統本地開發
version: '3.8'
services:
  postgres:
    image: postgres:14
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - ./init-scripts:/docker-entrypoint-initdb.d  # 初始化腳本
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
  
  flyway:
    image: flyway/flyway:8
    command: -url=jdbc:postgresql://postgres:5432/myapp -user=postgres -password=password migrate
    volumes:
      - ./migrations:/flyway/sql  # Migration 腳本
    depends_on:
      - postgres
  
  app:
    build: .
    environment:
      DATABASE_URL: postgresql://postgres:password@postgres:5432/myapp
    ports:
      - "3000:3000"
    depends_on:
      - flyway
    volumes:
      - .:/app  # 熱重載

volumes:
  postgres_data:
```

**開發流程**：
```bash
# 一鍵啟動所有服務
docker-compose up -d

# 查看日誌
docker-compose logs -f

# 進入數據庫
docker-compose exec postgres psql -U postgres -d myapp
```


Kubernetes 的挑戰
轉到 Kubernetes 後，同樣的事情變得複雜：

```mermaid
graph TB
    subgraph "🐳 Docker Compose 的美好"
        DC1[🚀 一鍵啟動]
        DC2[🔗 自動依賴管理]
        DC3[📁 簡單檔案掛載]
        DC4[🔥 熱重載支持]
        DC5[📊 統一日誌查看]
        DC6[🗄️ 自動 Migration]
    end
    
    subgraph "☸️ Kubernetes 的現實"
        K1[📄 多個 YAML 檔案]
        K2[🤯 複雜依賴關係]
        K3[⚙️ ConfigMap/Secret 管理]
        K4[🔌 手動端口轉發]
        K5[🔍 分散的日誌查看]
        K6[🛠️ 手動 Migration 執行]
    end
    
    DC1 -.->|變成| K1
    DC2 -.->|變成| K2
    DC3 -.->|變成| K3
    DC4 -.->|變成| K4
    DC5 -.->|變成| K5
    DC6 -.->|變成| K6
    
    style DC1 fill:#c8e6c9
    style DC2 fill:#c8e6c9
    style DC3 fill:#c8e6c9
    style DC4 fill:#c8e6c9
    style DC5 fill:#c8e6c9
    style DC6 fill:#c8e6c9
    style K1 fill:#ffcdd2
    style K2 fill:#ffcdd2
    style K3 fill:#ffcdd2
    style K4 fill:#ffcdd2
    style K5 fill:#ffcdd2
    style K6 fill:#ffcdd2
```
問題總結：

🤯 需要寫很多 YAML 檔案
🔗 手動管理服務依賴關係
🛠️ Migration 需要手動執行
📊 無法像 Docker Compose 一樣查看統一日誌
🔥 熱重載開發體驗差

💡 解決方案：DevSpace + Flyway
DevSpace 是什麼？
DevSpace 就像是 Kubernetes 版的 Docker Compose！


```mermaid
graph LR
    subgraph "👨‍💻 開發者體驗"
        DEV[開發者]
        CMD[一個命令]
    end
    
    subgraph "🚀 DevSpace 魔法"
        DS[DevSpace CLI]
        CONFIG[devspace.yaml]
    end
    
    subgraph "☸️ Kubernetes 複雜性"
        K8S[Kubernetes Cluster]
        DEPLOY[自動部署]
        SYNC[檔案同步]
        PF[端口轉發]
        LOGS[日誌聚合]
        FLYWAY[Flyway Migration]
    end
    
    DEV --> CMD
    CMD --> DS
    DS --> CONFIG
    CONFIG --> DEPLOY
    CONFIG --> SYNC
    CONFIG --> PF
    CONFIG --> LOGS
    CONFIG --> FLYWAY
    
    DEPLOY --> K8S
    SYNC --> K8S
    PF --> K8S
    LOGS --> K8S
    FLYWAY --> K8S
    
    style DEV fill:#e3f2fd
    style DS fill:#c8e6c9
    style CONFIG fill:#fff3e0
    style K8S fill:#f3e5f5
```


專案結構設計
讓我們建立一個完整的專案結構：
```
```bash
# 建立專案目錄
mkdir myapp-k8s-dev
cd myapp-k8s-dev

# 完整專案結構
myapp-k8s-dev/
├── devspace.yaml           # 🚀 DevSpace 配置（類似 docker-compose.yml）
├── k8s/                    # ☸️ Kubernetes 配置
│   ├── database/
│   │   ├── statefulset.yaml    # 資料庫主體
│   │   ├── service.yaml        # 資料庫服務
│   │   └── configmap.yaml      # 初始化腳本
│   ├── migration/
│   │   └── job.yaml            # Flyway Migration Job
│   └── app/
│       ├── deployment.yaml     # 應用程式部署
│       └── service.yaml        # 應用程式服務
├── database/
│   ├── init-scripts/       # 🗄️ 資料庫初始化腳本
│   │   ├── 01-init-db.sql
│   │   └── 02-seed-data.sql
│   └── migrations/         # 🔄 Flyway Migration 腳本
│       ├── V1__Create_users_table.sql
│       ├── V2__Create_posts_table.sql
│       └── V3__Add_indexes.sql
├── app/                    # 📱 應用程式代碼
│   ├── src/
│   ├── Dockerfile
│   └── package.json
└── scripts/                # 🛠️ 輔助腳本
    ├── setup-dev.sh
    └── reset-db.sh
```

**對比 Docker Compose**：
- `devspace.yaml` = `docker-compose.yml`
- `k8s/` = 服務定義（但更詳細）
- `database/` = 和 Docker Compose 一樣的資料庫檔案
- `scripts/` = 開發輔助工具

🗄️ 步驟一：設定資料庫與初始化
1. 資料庫初始化腳本
先準備我們的資料庫初始化腳本：

```sql
-- database/init-scripts/01-init-db.sql
-- 🎯 建立應用資料庫和用戶（類似 Docker Compose 的環境變數效果）

-- 建立應用資料庫
CREATE DATABASE myapp;

-- 建立應用用戶
CREATE USER appuser WITH ENCRYPTED PASSWORD 'apppassword';
GRANT ALL PRIVILEGES ON DATABASE myapp TO appuser;

-- 連接到應用資料庫
\c myapp;

-- 建立應用 schema
CREATE SCHEMA IF NOT EXISTS app;
GRANT ALL ON SCHEMA app TO appuser;

-- 設定搜尋路徑
ALTER USER appuser SET search_path = app, public;

-- 安裝必要擴展
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

SELECT 'Database initialized successfully' AS status;
```

```sql
-- database/init-scripts/02-seed-data.sql
-- 🌱 插入開發用測試資料

\c myapp;
SET search_path = app, public;

-- 建立基本使用者表（Flyway 之前的基礎資料）
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入測試使用者
INSERT INTO users (username, email, password_hash) VALUES
    ('admin', 'admin@example.com', crypt('admin123', gen_salt('bf'))),
    ('developer', 'dev@example.com', crypt('dev123', gen_salt('bf'))),
    ('tester', 'test@example.com', crypt('test123', gen_salt('bf')))
ON CONFLICT (username) DO NOTHING;

SELECT 'Seed data inserted successfully' AS status;
```

2. ConfigMap 配置
將初始化腳本包裝成 ConfigMap：
```yaml
# k8s/database/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-init-scripts
  labels:
    app: postgres
data:
  # 🎯 初始化腳本（會自動執行，類似 Docker Compose 的 /docker-entrypoint-initdb.d）
  01-init-db.sql: |
    -- 建立應用資料庫
    CREATE DATABASE myapp;
    
    -- 建立用戶
    CREATE USER appuser WITH ENCRYPTED PASSWORD 'apppassword';
    GRANT ALL PRIVILEGES ON DATABASE myapp TO appuser;
    
    -- 連接到應用資料庫
    \c myapp;
    
    -- 建立 schema
    CREATE SCHEMA IF NOT EXISTS app;
    GRANT ALL ON SCHEMA app TO appuser;
    
    -- 設定搜尋路徑
    ALTER USER appuser SET search_path = app, public;
    
    -- 建立擴展
    CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
    CREATE EXTENSION IF NOT EXISTS "pgcrypto";
    
    SELECT 'Database initialized successfully' AS status;

  02-seed-data.sql: |
    -- 連接到應用資料庫
    \c myapp;
    SET search_path = app, public;
    
    -- 建立基本表格
    CREATE TABLE IF NOT EXISTS users (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    -- 插入測試資料
    INSERT INTO users (username, email, password_hash) VALUES
        ('admin', 'admin@example.com', crypt('admin123', gen_salt('bf'))),
        ('developer', 'dev@example.com', crypt('dev123', gen_salt('bf'))),
        ('tester', 'test@example.com', crypt('test123', gen_salt('bf')))
    ON CONFLICT (username) DO NOTHING;
    
    SELECT 'Seed data inserted successfully' AS status;

---
# Secret 用於敏感資料
apiVersion: v1
kind: Secret
metadata:
  name: postgres-secret
type: Opaque
data:
  # echo -n "password" | base64
  POSTGRES_PASSWORD: cGFzc3dvcmQ=
  # echo -n "apppassword" | base64  
  APP_DB_PASSWORD: YXBwcGFzc3dvcmQ=
  # echo -n "postgresql://appuser:apppassword@postgres-service:5432/myapp" | base64
  DATABASE_URL: cG9zdGdyZXNxbDovL2FwcHVzZXI6YXBwcGFzc3dvcmRAcG9zdGdyZXMtc2VydmljZTo1NDMyL215YXBw
```

3. StatefulSet 配置

```yaml
# k8s/database/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
  labels:
    app: postgres
spec:
  serviceName: postgres-service
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:14-alpine
        ports:
        - containerPort: 5432
          name: postgres
        env:
        # 🎯 基本資料庫設定（類似 Docker Compose 環境變數）
        - name: POSTGRES_DB
          value: postgres
        - name: POSTGRES_USER  
          value: postgres
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_PASSWORD
        # 🎯 開發環境設定
        - name: POSTGRES_INITDB_ARGS
          value: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
        
        volumeMounts:
        # 🗄️ 資料持久化
        - name: postgres-data
          mountPath: /var/lib/postgresql/data
        # 🎯 初始化腳本掛載（類似 Docker Compose 的 volumes）
        - name: init-scripts
          mountPath: /docker-entrypoint-initdb.d
        
        # 🏥 健康檢查
        livenessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - postgres
          initialDelaySeconds: 30
          periodSeconds: 10
        
        readinessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - postgres
          initialDelaySeconds: 5
          periodSeconds: 5
      
      volumes:
      # 🎯 掛載初始化腳本
      - name: init-scripts
        configMap:
          name: postgres-init-scripts
  
  # 🗄️ 持久化儲存
  volumeClaimTemplates:
  - metadata:
      name: postgres-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi

---
# Service 用於內部通訊
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
  labels:
    app: postgres
spec:
  selector:
    app: postgres
  ports:
  - port: 5432
    targetPort: 5432
    name: postgres
  type: ClusterIP
```

🔄 步驟二：設定 Flyway Migration
1. Migration 腳本準備

```sql
-- database/migrations/V1__Create_users_table.sql
-- 🎯 建立使用者表格的正式版本（取代初始化腳本中的臨時版本）

-- 刪除臨時表格（如果存在）
DROP TABLE IF EXISTS users;

-- 建立正式的使用者表格
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    avatar_url VARCHAR(255),
    is_active BOOLEAN DEFAULT true,
    email_verified BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 建立索引
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_active ON users(is_active);

-- 插入初始管理員
INSERT INTO users (username, email, password_hash, first_name, last_name, is_active, email_verified) 
VALUES 
    ('admin', 'admin@example.com', crypt('admin123', gen_salt('bf')), 'Admin', 'User', true, true),
    ('developer', 'dev@example.com', crypt('dev123', gen_salt('bf')), 'Developer', 'User', true, true);
```

```sql
-- database/migrations/V2__Create_posts_table.sql
-- 🎯 建立文章表格

CREATE TABLE posts (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,
    content TEXT,
    excerpt VARCHAR(500),
    slug VARCHAR(200) UNIQUE NOT NULL,
    status VARCHAR(20) DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
    featured_image_url VARCHAR(255),
    published_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 建立索引
CREATE INDEX idx_posts_user_id ON posts(user_id);
CREATE INDEX idx_posts_status ON posts(status);
CREATE INDEX idx_posts_published_at ON posts(published_at);
CREATE INDEX idx_posts_slug ON posts(slug);

-- 插入範例文章
INSERT INTO posts (user_id, title, content, excerpt, slug, status, published_at)
SELECT 
    u.id,
    'Welcome to Our Platform',
    'This is your first post. You can edit or delete it, then start writing!',
    'Welcome post for new users',
    'welcome-to-our-platform',
    'published',
    CURRENT_TIMESTAMP
FROM users u WHERE u.username = 'admin';
```

```sql
-- database/migrations/V3__Add_user_profiles.sql
-- 🎯 新增使用者個人檔案功能

CREATE TABLE user_profiles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bio TEXT,
    location VARCHAR(100),
    website VARCHAR(255),
    twitter_handle VARCHAR(50),
    github_username VARCHAR(50),
    linkedin_url VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 確保每個使用者只有一個檔案
CREATE UNIQUE INDEX idx_user_profiles_user_id ON user_profiles(user_id);

-- 為現有使用者建立空檔案
INSERT INTO user_profiles (user_id, bio)
SELECT id, 'Hello! I am new to this platform.' 
FROM users 
WHERE NOT EXISTS (
    SELECT 1 FROM user_profiles WHERE user_profiles.user_id = users.id
);
```

2. Flyway Migration Job

```
```yaml
# k8s/migration/configmap.yaml - Migration 腳本
apiVersion: v1
kind: ConfigMap
metadata:
  name: flyway-migrations
  labels:
    app: flyway
data:
  V1__Create_users_table.sql: |
    -- 刪除臨時表格（如果存在）
    DROP TABLE IF EXISTS users;
    
    -- 建立正式的使用者表格
    CREATE TABLE users (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        first_name VARCHAR(50),
        last_name VARCHAR(50),
        avatar_url VARCHAR(255),
        is_active BOOLEAN DEFAULT true,
        email_verified BOOLEAN DEFAULT false,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    -- 建立索引
    CREATE INDEX idx_users_username ON users(username);
    CREATE INDEX idx_users_email ON users(email);
    CREATE INDEX idx_users_active ON users(is_active);
    
    -- 插入初始管理員
    INSERT INTO users (username, email, password_hash, first_name, last_name, is_active, email_verified) 
    VALUES 
        ('admin', 'admin@example.com', crypt('admin123', gen_salt('bf')), 'Admin', 'User', true, true),
        ('developer', 'dev@example.com', crypt('dev123', gen_salt('bf')), 'Developer', 'User', true, true);

  V2__Create_posts_table.sql: |
    CREATE TABLE posts (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        title VARCHAR(200) NOT NULL,
        content TEXT,
        excerpt VARCHAR(500),
        slug VARCHAR(200) UNIQUE NOT NULL,
        status VARCHAR(20) DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
        featured_image_url VARCHAR(255),
        published_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    -- 建立索引
    CREATE INDEX idx_posts_user_id ON posts(user_id);
    CREATE INDEX idx_posts_status ON posts(status);
    CREATE INDEX idx_posts_published_at ON posts(published_at);
    CREATE INDEX idx_posts_slug ON posts(slug);
    
    -- 插入範例文章
    INSERT INTO posts (user_id, title, content, excerpt, slug, status, published_at)
    SELECT 
        u.id,
        'Welcome to Our Platform',
        'This is your first post. You can edit or delete it, then start writing!',
        'Welcome post for new users',
        'welcome-to-our-platform',
        'published',
        CURRENT_TIMESTAMP
    FROM users u WHERE u.username = 'admin';

  V3__Add_user_profiles.sql: |
    CREATE TABLE user_profiles (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        bio TEXT,
        location VARCHAR(100),
        website VARCHAR(255),
        twitter_handle VARCHAR(50),
        github_username VARCHAR(50),
        linkedin_url VARCHAR(255),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    -- 確保每個使用者只有一個檔案
    CREATE UNIQUE INDEX idx_user_profiles_user_id ON user_profiles(user_id);
    
    -- 為現有使用者建立空檔案
    INSERT INTO user_profiles (user_id, bio)
    SELECT id, 'Hello! I am new to this platform.' 
    FROM users 
    WHERE NOT EXISTS (
        SELECT 1 FROM user_profiles WHERE user_profiles.user_id = users.id
    );

---
# k8s/migration/job.yaml - Flyway Migration Job
apiVersion: batch/v1
kind: Job
metadata:
  name: flyway-migration
  labels:
    app: flyway
spec:
  template:
    metadata:
      labels:
        app: flyway
    spec:
      restartPolicy: OnFailure
      
      # 🎯 等待資料庫就緒的 Init Container
      initContainers:
      - name: wait-for-db
        image: postgres:14-alpine
        command: ['/bin/sh', '-c']
        args:
        - |
          echo "🔍 等待資料庫就緒..."
          until pg_isready -h postgres-service -p 5432 -U postgres; do
            echo "資料庫未就緒，等待 3 秒..."
            sleep 3
          done
          
          echo "🔍 測試應用使用者連線..."
          until PGPASSWORD=$APP_DB_PASSWORD psql -h postgres-service -p 5432 -U appuser -d myapp -c "SELECT 1;" > /dev/null 2>&1; do
            echo "應用使用者連線失敗，等待 3 秒..."
            sleep 3
          done
          
          echo "✅ 資料庫完全就緒！"
        env:
        - name: APP_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: APP_DB_PASSWORD
      
      containers:
      - name: flyway
        image: flyway/flyway:8-alpine
        command: ['/bin/sh', '-c']
        args:
        - |
          echo "🚀 開始 Flyway Migration..."
          
          # 顯示目前狀態
          echo "📊 Migration 狀態（執行前）："
          flyway \
            -url=jdbc:postgresql://postgres-service:5432/myapp \
            -user=appuser \
            -password=$FLYWAY_PASSWORD \
            -locations=filesystem:/flyway/sql \
            -schemas=app \
            info || echo "首次執行，無歷史記錄"
          
          # 執行 Migration
          flyway \
            -url=jdbc:postgresql://postgres-service:5432/myapp \
            -user=appuser \
            -password=$FLYWAY_PASSWORD \
            -locations=filesystem:/flyway/sql \
            -schemas=app \
            -baselineOnMigrate=true \
            -validateOnMigrate=true \
            migrate
          
          # 顯示執行後狀態
          echo "📊 Migration 狀態（執行後）："
          flyway \
            -url=jdbc:postgresql://postgres-service:5432/myapp \
            -user=appuser \
            -password=$FLYWAY_PASSWORD \
            -locations=filesystem:/flyway/sql \
            -schemas=app \
            info
          
          echo "✅ Flyway Migration 完成！"
        
        env:
        - name: FLYWAY_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: APP_DB_PASSWORD
        
        volumeMounts:
        - name: flyway-migrations
          mountPath: /flyway/sql
      
      volumes:
      - name: flyway-migrations
        configMap:
          name: flyway-migrations
```
🚀 步驟三：DevSpace 配置 - 打造 Docker Compose 般的體驗
DevSpace 核心配置
這是關鍵！DevSpace 讓我們像使用 Docker Compose 一樣簡單：

```yaml
# devspace.yaml - 🎯 這就是我們的 "docker-compose.yml"
version: v2beta1
name: myapp-dev

# 🎯 類似 Docker Compose 的 services
deployments:
  # 資料庫部署
  database:
    kubectl:
      manifests:
      - k8s/database/configmap.yaml
      - k8s/database/statefulset.yaml
    
  # Migration 部署  
  migration:
    kubectl:
      manifests:
      - k8s/migration/configmap.yaml
      - k8s/migration/job.yaml
    # 🎯 類似 Docker Compose 的 depends_on
    dependsOn:
    - database
    
  # 應用程式部署
  app:
    kubectl:
      manifests:
      - k8s/app/deployment.yaml
      - k8s/app/service.yaml
    dependsOn:
    - migration  # 確保 Migration 完成後才啟動應用

# 🎯 類似 Docker Compose 的 ports
dev:
  ports:
  - imageSelector: postgres:14-alpine
    forward:
    - port: 5432
      remotePort: 5432
  - imageSelector: myapp:latest  
    forward:
    - port: 3000
      remotePort: 3000
  
  # 🎯 類似 Docker Compose 的 volumes（熱重載）
  sync:
  - imageSelector: myapp:latest
    localSubPath: ./app
    containerPath: /app
    excludePaths:
    - node_modules/
    - .git/
    
  # 🎯 類似 Docker Compose logs -f
  logs:
    showLast: 50
    sync: true

# 🛠️ 自訂指令（類似 Docker Compose 的便利指令）
commands:
  # 查看資料庫
  - name: db
    command: |
      echo "🗄️ 連接到資料庫..."
      kubectl exec -it statefulset/postgres -- psql -U appuser -d myapp
  
  # 重新執行 Migration
  - name: migrate
    command: |
      echo "🔄 重新執行 Migration..."
      kubectl delete job flyway-migration --ignore-not-found=true
      kubectl apply -f k8s/migration/job.yaml
      kubectl wait --for=condition=complete job/flyway-migration --timeout=300s
      kubectl logs job/flyway-migration
  
  # 查看 Migration 狀態
  - name: migration-status
    command: |
      echo "📊 檢查 Migration 狀態..."
      kubectl exec statefulset/postgres -- psql -U appuser -d myapp -c "
      SELECT installed_rank, version, description, installed_on, success 
      FROM app.flyway_schema_history 
      ORDER BY installed_rank;"
  
  # 重置資料庫（開發用）
  - name: reset-db
    command: |
      echo "⚠️  重置資料庫（這會刪除所有資料）"
      read -p "確定要繼續嗎？ (y/N): " confirm
      if [ "$confirm" = "y" ]; then
        echo "🗑️ 刪除資料庫..."
        kubectl exec statefulset/postgres -- psql -U postgres -c "DROP DATABASE IF EXISTS myapp;"
        kubectl exec statefulset/postgres -- psql -U postgres -c "CREATE DATABASE myapp;"
        kubectl exec statefulset/postgres -- psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE myapp TO appuser;"
        
        echo "🔄 重新執行初始化..."
        kubectl rollout restart statefulset/postgres
        kubectl rollout status statefulset/postgres
        
        echo "🔄 重新執行 Migration..."
        devspace run migrate
        
        echo "✅ 資料庫重置完成！"
      else
        echo "❌ 取消操作"
      fi
  
  # 查看所有服務狀態
  - name: status
    command: |
      echo "📊 服務狀態概覽："
      echo "===================="
      echo "🗄️ 資料庫："
      kubectl get statefulset postgres -o wide
      echo ""
      echo "🔄 Migration Job："
      kubectl get job flyway-migration -o wide 2>/dev/null || echo "Migration job not found"
      echo ""
      echo "📱 應用程式："
      kubectl get deployment myapp -o wide 2>/dev/null || echo "App deployment not found"
      echo ""
      echo "🌐 服務："
      kubectl get services

# 🎯 開發環境變數（類似 Docker Compose 的 environment）
vars:
  DB_HOST: postgres-service
  DB_PORT: "5432"
  DB_NAME: myapp
  DB_USER: appuser
```


應用程式配置
```yaml
# k8s/app/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  labels:
    app: myapp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      # 🎯 等待資料庫和 Migration 完成的 Init Container
      initContainers:
      - name: wait-for-migration
        image: postgres:14-alpine
        command: ['/bin/sh', '-c']
        args:
        - |
          echo "🔍 等待 Migration 完成..."
          
          # 等待資料庫可用
          until pg_isready -h postgres-service -p 5432 -U postgres; do
            echo "等待資料庫..."
            sleep 3
          done
          
          # 檢查 Flyway schema history 表是否存在（表示 Migration 已執行）
          until PGPASSWORD=$APP_DB_PASSWORD psql -h postgres-service -p 5432 -U appuser -d myapp -c "SELECT 1 FROM app.flyway_schema_history LIMIT 1;" > /dev/null 2>&1; do
            echo "等待 Migration 完成..."
            sleep 5
          done
          
          echo "✅ Migration 已完成，應用程式可以啟動！"
        env:
        - name: APP_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: APP_DB_PASSWORD
      
      containers:
      - name: app
        image: myapp:latest
        ports:
        - containerPort: 3000
        env:
        # 🎯 資料庫連線設定
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: DATABASE_URL
        - name: NODE_ENV
          value: development
        - name: PORT
          value: "3000"
        
        # 🏥 健康檢查
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        
        # 🎯 開發環境資源限制
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"

---
# k8s/app/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
  labels:
    app: myapp
spec:
  selector:
    app: myapp
  ports:
  - port: 3000
    targetPort: 3000
    name: http
  type: ClusterIP
```

🎮 步驟四：實際操作 - 像 Docker Compose 一樣簡單！
安裝 DevSpace

```bash
# 🚀 安裝 DevSpace（類似安裝 Docker Compose）

# macOS
brew install devspace

# Linux
curl -s -L "https://github.com/loft-sh/devspace/releases/latest" | sed -nE 's!.*"([^"]*devspace-linux-amd64)".*!https://github.com\1!p' | xargs -n 1 curl -L -o devspace && chmod +x devspace && sudo mv devspace /usr/local/bin

# Windows
# 下載 devspace.exe 並加入 PATH

# 驗證安裝
devspace --version
```

```bash
# 🎯 初始化專案（類似 docker-compose init）
cd myapp-k8s-dev

# DevSpace 會自動偵測 Kubernetes context
devspace use context  # 選擇你的 K8s cluster（如 minikube, kind, etc.）

# 初始化 DevSpace 配置
devspace init
```



一鍵啟動開發環境

```bash
# 🚀 一鍵啟動所有服務（就像 docker-compose up）
devspace dev

# 你會看到類似這樣的輸出：
# ==========================================
# 🚀 Starting development mode...
# 
# 📦 Deploying database...
# ✅ Database deployed successfully
# 
# 🔄 Deploying migration...  
# ✅ Migration completed successfully
# 
# 📱 Deploying app...
# ✅ App deployed successfully
# 
# 🔌 Port forwarding:
#    - postgres: localhost:5432 -> pod:5432
#    - app: localhost:3000 -> pod:3000
# 
# 📁 File sync active:
#    - ./app -> /app (in container)
# 
# 📊 Streaming logs...
# ==========================================
```

```bash
# 🎯 常用開發指令（類似 Docker Compose 指令）

# 查看資料庫（類似 docker-compose exec postgres psql）
devspace run db

# 重新執行 Migration（類似 docker-compose restart flyway）
devspace run migrate

# 查看 Migration 狀態
devspace run migration-status

# 查看所有服務狀態（類似 docker-compose ps）
devspace run status

# 重置資料庫（開發用）
devspace run reset-db

# 查看即時日誌（類似 docker-compose logs -f）
devspace logs -f

# 停止開發環境（類似 docker-compose down）
devspace purge
```





Migration 開發工作流程
```mermaid
graph TD
    START[開始開發] --> DEV[devspace dev]
    DEV --> DB[資料庫自動啟動]
    DB --> INIT[執行初始化腳本]
    INIT --> MIGRATION[執行 Flyway Migration]
    MIGRATION --> APP[應用程式啟動]
    APP --> READY[開發環境就緒]
    
    READY --> NEWMIG[新增 Migration 檔案]
    NEWMIG --> RUNMIG[devspace run migrate]
    RUNMIG --> TEST[測試新功能]
    TEST --> READY
    
    READY --> RESET[需要重置資料庫？]
    RESET --> RESETDB[devspace run reset-db]
    RESETDB --> DB
    
    READY --> STOP[開發完成]
    STOP --> PURGE[devspace purge]
    
    style START fill:#c8e6c9
    style READY fill:#e3f2fd
    style NEWMIG fill:#fff3e0
    style RESET fill:#ffcdd2
    style STOP fill:#f3e5f5
```

🧪 步驟五：實際測試 Migration 功能
新增一個 Migration
讓我們實際演示如何在開發過程中新增 Migration：

```sql
-- database/migrations/V4__Add_comments_table.sql
-- 🎯 新增留言功能

CREATE TABLE comments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    post_id UUID NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    parent_comment_id UUID REFERENCES comments(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    is_approved BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 建立索引
CREATE INDEX idx_comments_post_id ON comments(post_id);
CREATE INDEX idx_comments_user_id ON comments(user_id);
CREATE INDEX idx_comments_parent_id ON comments(parent_comment_id);
CREATE INDEX idx_comments_approved ON comments(is_approved);

-- 插入範例留言
INSERT INTO comments (post_id, user_id, content, is_approved)
SELECT 
    p.id,
    u.id,
    'Great post! Thanks for sharing.',
    true
FROM posts p
CROSS JOIN users u 
WHERE p.slug = 'welcome-to-our-platform' 
  AND u.username = 'developer'
LIMIT 1;
```

**實際操作流程**：
```bash
# 1. 🎯 建立新的 Migration 檔案
echo "建立 V4__Add_comments_table.sql..."

# 2. 🔄 更新 ConfigMap（在實際專案中，你可能會用 Kustomize 或 Helm）
# 編輯 k8s/migration/configmap.yaml，加入新的 Migration

# 3. 🚀 執行 Migration
devspace run migrate

# 你會看到：
# 🔄 重新執行 Migration...
# job.batch "flyway-migration" deleted
# job.batch/flyway-migration created
# job.batch/flyway-migration condition met
# 
# 📊 Migration 狀態（執行前）：
# +---------+---------+---------------------+------+---------------------+---------+
# | Version | Description | Type            | State| Installed On        | Undoable|
# +---------+---------+---------------------+------+---------------------+---------+
# | 1       | Create users table | SQL   | Success | 2024-01-15 10:30:00 | No      |
# | 2       | Create posts table | SQL   | Success | 2024-01-15 10:30:05 | No      |
# | 3       | Add user profiles  | SQL   | Success | 2024-01-15 10:30:10 | No      |
# +---------+---------+---------------------+------+---------------------+---------+
# 
# 🚀 開始 Flyway Migration...
# Migrating schema "app" to version "4 - Add comments table"
# Successfully applied 1 migration to schema "app"
# 
# 📊 Migration 狀態（執行後）：
# +---------+---------+---------------------+------+---------------------+---------+
# | Version | Description | Type            | State| Installed On        | Undoable|
# +---------+---------+---------------------+------+---------------------+---------+
# | 1       | Create users table | SQL   | Success | 2024-01-15 10:30:00 | No      |
# | 2       | Create posts table | SQL   | Success | 2024-01-15 10:30:05 | No      |
# | 3       | Add user profiles  | SQL   | Success | 2024-01-15 10:30:10 | No      |
# | 4       | Add comments table | SQL   | Success | 2024-01-15 10:35:15 | No      |
# +---------+---------+---------------------+------+---------------------+---------+
# 
# ✅ Flyway Migration 完成！

# 4. 🔍 驗證新表格
devspace run db
# 在 psql 中執行：
# \dt app.*
# SELECT * FROM app.comments;

# 5. 📊 查看 Migration 歷史
devspace run migration-status
```

開發中的常見情境
## 🎯 情境一：Migration 執行失敗

```bash
# 如果 Migration 失敗，你會看到：
# ❌ Migration failed: Syntax error at line 15

# 解決步驟：
# 1. 檢查 Migration 日誌
kubectl logs job/flyway-migration

# 2. 修正 Migration 檔案
# 編輯 database/migrations/V4__Add_comments_table.sql

# 3. 更新 ConfigMap
kubectl apply -f k8s/migration/configmap.yaml

# 4. 重新執行 Migration
devspace run migrate
```

## 🎯 情境二：需要回滾資料庫

```bash
# Flyway 不支援自動回滾，但我們可以重置資料庫
devspace run reset-db

# 或者手動建立回滾腳本
# database/migrations/V5__Rollback_comments.sql
```

## 🎯 情境三：多人協作 Migration 衝突

```bash
# 當多個開發者同時新增 Migration 時：
# Developer A: V4__Add_comments.sql
# Developer B: V4__Add_tags.sql  ← 衝突！

# 解決方案：
# 1. 重新命名其中一個為 V5
# 2. 或使用時間戳版本號：V20240115103000__Add_tags.sql

# 3. 重新同步
devspace run migrate
```

## 🎯 情境四：測試資料管理

```bash
# 建立測試資料腳本
# database/migrations/V999__Test_data.sql（開發環境專用）

CREATE OR REPLACE FUNCTION insert_test_data() RETURNS void AS $$
BEGIN
    -- 只在開發環境執行
    IF current_setting('server_version_num')::int >= 140000 THEN
        -- 插入大量測試資料
        INSERT INTO posts (user_id, title, content, slug, status, published_at)
        SELECT 
            (SELECT id FROM users ORDER BY random() LIMIT 1),
            'Test Post ' || generate_series,
            'This is test content for post ' || generate_series,
            'test-post-' || generate_series,
            'published',
            CURRENT_TIMESTAMP - (generate_series || ' days')::interval
        FROM generate_series(1, 100);
    END IF;
END;
$$ LANGUAGE plpgsql;

SELECT insert_test_data();
```

📊 完整工作流程總結
DevSpace vs Docker Compose 對比
| 功能 | Docker Compose | DevSpace + K8s | 說明 |
|------|----------------|----------------|------|
| **🚀 一鍵啟動** | `docker-compose up` | `devspace dev` | 都能一鍵啟動所有服務 |
| **🔗 依賴管理** | `depends_on` | `dependsOn` | 自動管理服務啟動順序 |
| **📁 檔案同步** | `volumes: - .:/app` | `sync` 配置 | 支援熱重載開發 |
| **🔌 端口轉發** | `ports: - "3000:3000"` | `ports` 配置 | 自動端口轉發 |
| **📊 日誌查看** | `docker-compose logs -f` | `devspace logs -f` | 統一日誌查看 |
| **🗄️ 資料庫連線** | `docker-compose exec db psql` | `devspace run db` | 快速資料庫存取 |
| **🔄 Migration** | 手動重啟服務 | `devspace run migrate` | 更靈活的 Migration 管理 |
| **🛠️ 除錯能力** | 基本 | 更強大 | K8s 提供更多監控和除錯工具 |
| **🏭 生產就緒** | 需要額外配置 | 原生支援 | 開發環境直接對應生產環境 |
| **📈 擴展性** | 有限 | 無限 | K8s 提供更好的擴展能力 |

最佳實踐建議

## 🎯 Migration 最佳實踐

### ✅ 建議做法
```sql
-- ✅ 使用描述性的檔案名稱
V1__Create_users_table.sql
V2__Add_user_email_index.sql
V3__Update_user_schema_for_oauth.sql

-- ✅ 總是包含 IF EXISTS 檢查
CREATE TABLE IF NOT EXISTS users (...);
ALTER TABLE users ADD COLUMN IF NOT EXISTS email_verified BOOLEAN DEFAULT false;

-- ✅ 使用交易（Flyway 會自動包裝，但明確更好）
BEGIN;
-- your migration code
COMMIT;

-- ✅ 包含回滾說明
-- Rollback: DROP TABLE comments;
CREATE TABLE comments (...);
```

### ❌ 避免的做法
```sql
-- ❌ 不要直接刪除資料
DROP TABLE old_table;  -- 危險！

-- ❌ 不要使用模糊的版本號
V1.sql, V2.sql  -- 不夠描述性

-- ❌ 不要在 Migration 中使用環境特定的資料
INSERT INTO users VALUES ('specific-prod-user', ...);  -- 應該分離
```

## 🛠️ DevSpace 最佳實踐

### ✅ 建議配置
```yaml
# ✅ 使用明確的依賴關係
deployments:
  database:
    kubectl:
      manifests: [...]
  migration:
    dependsOn: [database]  # 明確依賴
  app:
    dependsOn: [migration]  # 確保 Migration 完成

# ✅ 配置適當的資源限制
resources:
  requests:
    memory: "128Mi"
    cpu: "100m"
  limits:
    memory: "512Mi"
    cpu: "500m"

# ✅ 使用健康檢查
livenessProbe:
  httpGet:
    path: /health
    port: 3000
```

# 🧠 總結 Mind Map
```mermaid
mindmap
  root((Day 11<br/>DevSpace + Flyway<br/>本地開發實踐))
    🎯 學習目標
      從 Docker Compose 轉換到 K8s
      簡化本地開發流程
      自動化 Migration 管理
      建立完整開發工作流
    
    🐳 Docker Compose 回顧
      一鍵啟動 `docker-compose up`
      自動依賴管理 `depends_on`
      簡單檔案掛載 `volumes`
      統一日誌查看 `logs -f`
      
    ☸️ Kubernetes 挑戰
      多個 YAML 檔案
      複雜依賴關係
      手動端口轉發
      分散的日誌查看
      
    🚀 DevSpace 解決方案
      devspace.yaml 配置
        類似 docker-compose.yml
        deployments 定義服務
        dependsOn 管理依賴
        ports 自動轉發
        sync 熱重載
      一鍵開發 `devspace dev`
      自訂指令 `devspace run`
      
    🗄️ 資料庫設定
      StatefulSet 配置
      ConfigMap 初始化腳本
      Secret 敏感資料管理
      持久化儲存
      
    🔄 Flyway Migration
      Migration 腳本管理
        V1__Create_users_table.sql
        V2__Create_posts_table.sql
        版本化 Schema 變更
      Job 配置
        等待資料庫就緒
        自動執行 Migration
        狀態回報
      開發工作流
        新增 Migration
        測試執行
        狀態檢查
        
    🛠️ 實際操作
      安裝 DevSpace
      專案結構設計
      配置檔案撰寫
      一鍵啟動測試
      Migration 實驗
      
    📊 最佳實踐
      Migration 設計原則
        描述性檔案名稱
        包含回滾說明
        避免破壞性變更
      團隊協作
        統一開發環境
        版本控制整合
        CI/CD 整合
        
    🎉 學習成果
      像 Docker Compose 一樣簡單
      更強大的 K8s 功能
      自動化 Migration 管理
      完整的開發工作流
```

### 🎯 團隊協作建議
```bash
# ✅ 建立團隊腳本
# scripts/team-setup.sh
#!/bin/bash
echo "🚀 設定團隊開發環境..."

# 檢查必要工具
command -v devspace >/dev/null 2>&1 || { echo "請安裝 DevSpace"; exit 1; }
command -v kubectl >/dev/null 2>&1 || { echo "請安裝 kubectl"; exit 1; }

# 設定 K8s context
echo "選擇 Kubernetes context:"
kubectl config get-contexts

# 啟動開發環境
devspace dev
```



# 總結
✅ 解決了什麼問題 
🐳 → ☸️ 平滑轉換：從 Docker Compose 的簡單體驗轉換到 Kubernetes 的強大功能
🔄 自動化 Migration：不再需要手動執行資料庫 Migration
🚀 一鍵開發環境：devspace dev 就像 docker-compose up 一樣簡單
📊 統一管理：資料庫、Migration、應用程式的完整生命週期管理
🎯 核心技能獲得
DevSpace 配置：學會寫 devspace.yaml 來管理複雜的 K8s 環境
Flyway Integration：掌握在 K8s 中自動化執行資料庫 Migration
依賴管理：理解如何在 K8s 中管理服務啟動順序
開發工作流：建立了完整的本地開發到測試的流程


```mermaid
graph LR
    DEV[開發者] --> DS[DevSpace CLI]
    DS --> K8S[Kubernetes Cluster]
    DS --> SYNC[文件同步]
    DS --> PF[端口轉發]
    DS --> LOGS[日誌聚合]
    
    style DS fill:#e3f2fd
    style SYNC fill:#c8e6c9
    style PF fill:#fff3e0
    style LOGS fill:#f3e5f5
```
